use crate::semant::typed_ast::{TBlock, TExpr, TStmt, TToplevelStmt, TypedAst};
use crate::syntax::ast::{Literal, Ty};

mod headers;

#[derive(Debug, Clone, PartialEq)]
pub struct Compiler {
    pub code: String,
}

impl Compiler {
    pub fn new() -> Self {
        Compiler { code: String::new() }
    }

    fn emit(&mut self, code: &str) {
        self.code.push_str(code);
    }

    fn build_header(&mut self) {
        self.emit("//\n");
        self.emit("// This file was generated by the stage1 Deimos compiler\n");
        self.emit("// Do not modify this file directly\n");
        self.emit("//\n\n");

        self.emit("typedef int i32;\n");
        self.emit("typedef float f32;\n");
        self.emit("typedef double f64;\n");
        self.emit("typedef _Bool bool;\n");
        self.emit("typedef const char* string;\n\n");
    }

    fn build_function_pointer(&mut self, ret_ty: Ty, params: Vec<Ty>) -> String {
        let mut code = String::new();
        code.push_str("(");
        for (index, param) in params.iter().enumerate() {
            code.push_str(&self.get_typename(param.clone()));

            if index < params.len() - 1 {
                code.push_str(", ");
            }
        }
        code.push_str(")(");
        code.push_str(&self.get_typename(ret_ty));
        code.push_str(")");
        code
    }

    fn get_typename(&mut self, ty: Ty) -> String {
        match ty {
            Ty::Int => "i32".to_string(),
            Ty::Float => "f32".to_string(),
            Ty::Double => "f64".to_string(),
            Ty::Bool => "bool".to_string(),
            Ty::String => "string".to_string(),
            Ty::Void => "void".to_string(),
            Ty::Function(ret_ty, params) => self.build_function_pointer(*ret_ty, params),
            Ty::Array(ty) => format!("{}*", self.get_typename(*ty)),
            Ty::Pointer(ty) => format!("{}*", self.get_typename(*ty)),
            Ty::UserDefined(name) => name,
            _ => unimplemented!(),
        }
    }

    fn compile_literal(&mut self, literal: Literal) {
        match literal {
            Literal::Int(i) => self.emit(&format!("{}", i)),
            Literal::Float(f) => self.emit(&format!("{}f", f)),
            Literal::Double(f) => self.emit(&format!("{}", f)),
            Literal::Bool(b) => self.emit(&format!("{}", b)),
            Literal::String(s) => self.emit(&format!("{:?}", s)),
        }
    }

    fn compile_expr(&mut self, expr: &TExpr) {
        match expr {
            TExpr::Literal(lit, _) => self.compile_literal(lit.clone()),
            TExpr::Variable(name, _) => self.emit(name),
            TExpr::BinOp(lhs, op, rhs) => {
                self.emit("(");
                self.compile_expr(&lhs.target);
                self.emit(" ");
                self.emit(&format!("{}", op.to_str()));
                self.emit(" ");
                self.compile_expr(&rhs.target);
                self.emit(")");
            }
            TExpr::UnOp(op, expr) => {
                self.emit(&format!("{:?}", op));
                self.compile_expr(&expr.target);
            }
            TExpr::Array { elems } => {
                self.emit("{");
                for elem in elems {
                    self.compile_expr(&elem.target);
                    self.emit(", ");
                }
                self.emit("}");
            }
            TExpr::StructCons { fields } => {
                self.emit("{");
                for (name, expr) in fields {
                    self.emit(&format!(".{} = ", name));
                    self.compile_expr(&expr.target);
                    self.emit(", ");
                }
                self.emit("}");
            }
            TExpr::ArrayIndex { array, index } => {
                self.compile_expr(&array.target);
                self.emit("[");
                self.compile_expr(&index.target);
                self.emit("]");
            }
            TExpr::Call { callee, args } => {
                self.compile_expr(&callee.target);
                self.emit("(");
                for arg in args {
                    self.compile_expr(&arg.target);
                    self.emit(", ");
                }
                self.emit(")");
            }
            _ => unimplemented!()
        }
    }

    fn compile_stmt(&mut self, stmt: &TStmt) {
        match stmt {
            TStmt::Expr(expr) => {
                self.compile_expr(&expr);
                self.emit(";\n");
            }
            TStmt::Return(expr) => {
                self.emit("return ");
                if let Some(expr) = expr {
                    self.compile_expr(&expr.target);
                }
                self.emit(";\n");
            }
            TStmt::VarDecl { name, ty, value } => {
                // If we don't know the type, assume void since it's most generic
                let typename = self.get_typename(ty.clone().unwrap_or(Ty::Void));
                self.emit(&format!("{} {} = ", typename, name));
                if let Some(value) = value {
                    self.compile_expr(&value.target);
                }
                self.emit(";\n");
            }
            TStmt::Assign { target, value } => {
                self.compile_expr(&target);
                self.emit(" = ");
                self.compile_expr(&value.target);
                self.emit(";\n");
            }
            _ => unimplemented!()
        }
    }

    fn compile_block(&mut self, block: &TBlock) {
        self.emit("{\n");
        for stmt in block {
            self.compile_stmt(&stmt.target);
        }
        self.emit("}\n");
    }

    fn compile_toplevel_stmt(&mut self, stmt: &TToplevelStmt) {
        match stmt {
            TToplevelStmt::StructDecl { name, fields } => {
                self.emit("typedef struct ");
                self.emit(name);
                self.emit(" {\n");
                for (field_name, field_ty) in fields {
                    let typ = self.get_typename(field_ty.clone());
                    self.emit(&format!("    {} {};\n", typ, field_name));
                }
                self.emit(&format!("}} {};\n", name));
            }
            TToplevelStmt::EnumDecl { name, fields } => {
                self.emit("typedef enum ");
                self.emit(name);
                self.emit(" {\n");
                for field_name in fields {
                    self.emit(&format!("    {};\n", field_name));
                }
                self.emit(&format!("}} {};\n", name));
            }
            TToplevelStmt::FunctionDecl { name, params, return_ty, body } => {
                let typ = self.get_typename(return_ty.clone());

                self.emit(&format!("{} {}(", typ, name));
                for (index, (param_name, param_ty)) in params.iter().enumerate() {
                    let typ2 = self.get_typename(param_ty.clone());

                    self.emit(&format!("{} {}", typ2, param_name));
                    if index < params.len() - 1 {
                        self.emit(", ");
                    }
                }
                self.emit(") ");
                self.compile_block(body);
            }

            // A statement can _also_ be a top-level statement
            TToplevelStmt::Stmt(stmt) => self.compile_stmt(&stmt.target),
            _ => unimplemented!()
        }
    }

    fn compile_ast(&mut self, ast: &TypedAst) {
        self.build_header();
        for stmt in ast.nodes.clone() {
            self.compile_toplevel_stmt(&stmt.target);
        }
    }

    pub fn compile(ast: &TypedAst) -> Compiler {
        let mut compiler = Compiler::new();
        compiler.compile_ast(ast);
        compiler
    }
}

#[cfg(test)]
mod tests {
    use crate::syntax::lexer::BinOp;
    use crate::syntax::span::spanned;

    use super::*;

    #[test]
    fn compile_expr() {
        let mut compiler = Compiler::new();
        let expr = TExpr::BinOp(
            Box::new(spanned(
                TExpr::Literal(Literal::Int(1), Ty::Int),
                0..1,
            )),
            BinOp::Add,
            Box::new(spanned(
                TExpr::Literal(Literal::Int(2), Ty::Int),
                0..1,
            )),
        );

        compiler.compile_expr(&expr);
        println!("{}", compiler.code);

        //assert_eq!(compiler.code, "1 + 2");
    }

    #[test]
    fn compile_type() {
        let mut compiler = Compiler::new();
        let ty = Ty::Function(Box::new(Ty::Int), vec![Ty::Int, Ty::String]);
        println!("{}", compiler.get_typename(ty.clone()));
        assert_eq!(compiler.get_typename(ty), "(i32, string)(i32)");

        let ty = Ty::Array(Box::new(Ty::Int));
        println!("{}", compiler.get_typename(ty.clone()));
        assert_eq!(compiler.get_typename(ty), "i32*");

        let ty = Ty::Pointer(Box::new(Ty::Int));
        println!("{}", compiler.get_typename(ty.clone()));
        assert_eq!(compiler.get_typename(ty), "i32*");

        let ty = Ty::Pointer(Box::new(Ty::UserDefined("Foo".to_string())));
        println!("{}", compiler.get_typename(ty.clone()));
        assert_eq!(compiler.get_typename(ty), "Foo*");
    }

    #[test]
    fn compile_stmt() {
        let mut compiler = Compiler::new();
        let stmt = TStmt::VarDecl {
            name: "x".to_string(),
            ty: Some(Ty::Int),
            value: Some(spanned(TExpr::Literal(Literal::Int(1), Ty::Int), 0..1)),
        };

        compiler.build_header();
        compiler.compile_stmt(&stmt);
        println!("{}", compiler.code);
    }
}